{% set version = "0.1" %}

{% set defisa = "avx2" %}
{% set isa = environ.get("PSI_BUILD_ISA", defisa) %}


package:
  name: gau2grid
  version: {{ version }}

source:
  git_url: git@github.com:dgasmith/gau2grid.git         # [linux]
  git_url: https://github.com/dgasmith/gau2grid.git     # [osx]
  git_tag: 9026f9e
  #git_tag: v{{ version }}

build:
  number: 0                                            # [linux]
  #number: 0                                            # [osx]
  binary_relocation: true
  skip: true                                           # [win]
  script_env:
    - PSI_BUILD_ISA                                    # [osx]
  {% if isa != defisa %}
  features:
    - {{ isa }}                                        # [osx]
  {% endif %}

requirements:
  build:
    - cmake >=3.0
    - mpmath
    - numpy
    - python x.x
    {% if isa != defisa %}
    - {{ isa }}        # [osx]    # for oldmac selection
  run:
    - {{ isa }}        # [osx]    # track oldmac
    {% endif %}
#    - gcc              ## [osx]    # build w/conda gcc
#  run:
#    - libgcc           ## [osx]    # link libgcc_s

test:
  #requires:
  #  - pytest
  commands:
    # Verify library
    - test -f $PREFIX/lib/libgg$SHLIB_EXT
    # Inspect linkage
    - ldd -v $PREFIX/lib/libgg.so                 # [linux]
    - otool -L $PREFIX/lib/libgg.dylib            # [osx]
    - conda-inspect linkages gau2grid --show-files
    # Actually test
    #- py.test -v --durations=5

about:
  home: https://github.com/dgasmith/gau2grid
  license: BSD-3-Clause
  license_url: https://opensource.org/licenses/BSD-3-Clause
  license_family: BSD
  summary: "D.G.A. Smith's C library for fast computation of a Gaussian and its derivative on a grid"
  readme: README.md
  description: >
    A collocation code for computing gaussians on a grid of the form:
    ```
    out_Lp = x^l y^m z^n \sum_i coeff_i e^(exponent_i * (|center - p|)^2)
    ```
    Where the returned matrix dimension are the angular momentum (L) by number of requested points (p).
    
    ```python
    import gau2grid
    import numpy as np
    
    # Build coordinates along the Z axis
    >>> xyz = np.zeros((3, 5))
    >>> xyz[2] = np.arange(5)
    
    # Compute a 's' gaussian with a scaling and exponent of one at the origin
    >>> ret = gau2grid.collocation(xyz, 0, [1], [1], [0, 0, 0])
    >>> print(ret["PHI"])
    [[  1.00000e+00   3.67879e-01   1.83156e-02   1.23409e-04   1.12535e-07]]
    
    # Compute a 'p' gaussian with a scaling and exponent of one at the origin
    >>> ret = gau2grid.collocation(xyz, 1, [1], [1], [0, 0, 0], spherical=False)
    >>> print(ret["PHI"])
    ((  0.00000e+00   0.00000e+00   0.00000e+00   0.00000e+00   0.00000e+00)
     (  0.00000e+00   0.00000e+00   0.00000e+00   0.00000e+00   0.00000e+00)
     (  0.00000e+00   3.67879e-01   3.66312e-02   3.70229e-04   4.50140e-07))
    
    # Note that the X and Y components are zero as they are orthogonal to our Z vector.
    ```
    
    The returned matrix can be in either cartesian or regular solid harmonics. There are currently
    three algorithms in which to compute these collocation matrices:
     - Optimize C: A autogenerated C library that optimizes for cache,
        vectorization, and sparsity. Fastest, requires compilation, found at
        `gau2grid.collocation`.
    - Optimized/Generated NumPy: A exploratory tool to
        examine the sparsity in the gaussians. No compilation required, found at
        `gau2grid.np_gen.collocation`.
    - NumPy Reference: A simple NumPy-based loop
        code. No compilation required, found at `gau2grid.ref.collocation`.

